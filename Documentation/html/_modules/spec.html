

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spec &mdash; pymzML 0.7.4 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pymzML 0.7.4 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">pymzML 0.7.4 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for spec</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python3.2</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># encoding: utf-8</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Spectrum class offers a python object for mass spectrometry data.</span>
<span class="sd">The spectrum object holds the basic information on the spectrum and offers</span>
<span class="sd">methods to interrogate properties of the spectrum.</span>
<span class="sd">Data, i.e. mass over charge (m/z) and intensity decoding is performed on demand</span>
<span class="sd">and can be accessed via their properties, e.g. :py:attr:`spec.Spectrum.peaks`.</span>

<span class="sd">The Spectrum class is used in the :py:class:`run.Run` class.</span>
<span class="sd">There each spectrum is accessible as a Spectrum object.</span>

<span class="sd">Theoretical spectra can also be created using the setter functions.</span>
<span class="sd">For example, m/z values, intensities, and peaks can be set by the</span>
<span class="sd">corresponding properties: :py:attr:`spec.Spectrum.mz`,</span>
<span class="sd">:py:attr:`spec.Spectrum.i`, :py:attr:`spec.Spectrum.peaks`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c">#</span>
<span class="c"># pymzml</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2010-2011 T. Bald, J. Barth, M. Specht, C. Fufezan</span>
<span class="c">#</span>
<span class="c">#    This program is free software: you can redistribute it and/or modify</span>
<span class="c">#    it under the terms of the GNU General Public License as published by</span>
<span class="c">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">#    (at your option) any later version.</span>
<span class="c">#</span>
<span class="c">#    This program is distributed in the hope that it will be useful,</span>
<span class="c">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">#    GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c">#    You should have received a copy of the GNU General Public License</span>
<span class="c">#    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="n">b64decode</span> <span class="k">as</span> <span class="n">b64dec</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">unpack</span> <span class="k">as</span> <span class="n">unpack</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span> <span class="k">as</span> <span class="n">ddict</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span> <span class="k">as</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">zlib</span>

<span class="n">PROTON</span> <span class="o">=</span> <span class="mf">1.00727646677</span>
<span class="n">ISOTOPE_AVERAGE_DIFFERENCE</span> <span class="o">=</span> <span class="mf">1.002</span>

<div class="viewcode-block" id="Spectrum"><a class="viewcode-back" href="../spec.html#spec.Spectrum">[docs]</a><span class="k">class</span> <span class="nc">Spectrum</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<div class="viewcode-block" id="Spectrum.__init__"><a class="viewcode-back" href="../spec.html#spec.Spectrum.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measuredPrecision</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. function:: __init__( measuredPrecision = value* )</span>

<span class="sd">            Initializes a pymzml.spec.Spectrum class.</span>

<span class="sd">            :param measuredPrecision: in m/z, mandatory</span>
<span class="sd">            :type measuredPrecision: float</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">measuredPrecision</span> <span class="p">,</span> <span class="nb">float</span> <span class="p">),</span> <span class="s">&quot;Require measured precision as input parameter...&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span> <span class="o">=</span> <span class="n">measuredPrecision</span>          <span class="c"># this will also set and update internalPrecision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c">#self._time = self._mz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Spectrum.__add__"><a class="viewcode-back" href="../spec.html#spec.Spectrum.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">otherSpec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds two pymzml spectra together.</span>

<span class="sd">        :param otherSpec: Spectrum object</span>
<span class="sd">        :type otherSpec: object</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml</span>
<span class="sd">        &gt;&gt;&gt; s = pymzml.spec.Spectrum( measuredPrescision = 20e-6 )</span>
<span class="sd">        &gt;&gt;&gt; file_to_read = &quot;../mzML_example_files/xy.mzML.gz&quot;</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(file_to_read , MS1_Precision = 5e-6 , MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spec in run:</span>
<span class="sd">        ...     s += spec</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">otherSpec</span><span class="p">,</span><span class="n">Spectrum</span><span class="p">)</span> <span class="p">,</span> <span class="s">&quot;can only add two pymzML spectra together ...&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deRef</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofile_Peaks</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">otherSpec</span><span class="o">.</span><span class="n">reprofiledPeaks</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span><span class="p">[</span><span class="n">mz</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span>

        <span class="c"># deleting original data since we have now a combination of specs</span>
        <span class="n">tmp_reprofiledPeaks</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span>

        <span class="n">tmp</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="n">tmp_reprofiledPeaks</span>
        <span class="n">tmp</span><span class="p">[</span><span class="s">&#39;reprofiled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">tmp</span>
</div>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">otherSpec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtracts two pymzml spectra.</span>
<span class="sd">        </span>
<span class="sd">        :param otherSpec: Spectrum object</span>
<span class="sd">        :type otherSpec: object</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">otherSpec</span><span class="p">,</span><span class="n">Spectrum</span><span class="p">)</span> <span class="p">,</span> <span class="s">&quot;can only subtract two pymzML spectra ...&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deRef</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofile_Peaks</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">otherSpec</span><span class="o">.</span><span class="n">reprofiledPeaks</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span><span class="p">[</span><span class="n">mz</span><span class="p">]</span> <span class="o">-=</span> <span class="n">i</span>

        <span class="c"># deleting original data since we have now a combination of specs</span>
        <span class="n">tmp_reprofiledPeaks</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span>

        <span class="n">tmp</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="n">tmp_reprofiledPeaks</span>
        <span class="n">tmp</span><span class="p">[</span><span class="s">&#39;reprofiled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">tmp</span>

<div class="viewcode-block" id="Spectrum.__mul__"><a class="viewcode-back" href="../spec.html#spec.Spectrum.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiplies each intensity with a float, i.e. scales the spectrum.</span>

<span class="sd">        :param value: Value to multiply the spectrum</span>
<span class="sd">        :type value: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s">&quot;require float or int of intensity values ...&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deRef</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">peaks</span>  <span class="o">=</span> <span class="p">[(</span><span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">peaks</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">centroidedPeaks</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">mz</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span><span class="p">[</span><span class="n">mz</span><span class="p">]</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span>
</div>
<div class="viewcode-block" id="Spectrum.__truediv__"><a class="viewcode-back" href="../spec.html#spec.Spectrum.__truediv__">[docs]</a>    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divides each intensity by a float, i.e. scales the spectrum.</span>

<span class="sd">        :param value: Value to divide the spectrum</span>
<span class="sd">        :type value: float, int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span> <span class="p">,</span> <span class="p">(</span> <span class="nb">int</span> <span class="p">,</span> <span class="nb">float</span> <span class="p">)</span> <span class="p">),</span> <span class="s">&quot;require float or int of intensity values ...&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deRef</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">peaks</span>  <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">peaks</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">centroidedPeaks</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">centroidedPeaks</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">mz</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_reprofiledPeaks</span><span class="p">[</span><span class="n">mz</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span>
</div>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__truediv__</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the current spectrum object which means that all variables are</span>
<span class="sd">        set to default or ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scope</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deconvolutedPeaks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMzWithError</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformedPeaks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_deconvolutedPeaks</span>  <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMassWithError</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extremeValues</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tmzSet</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tmassSet</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaksSortedByI</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xmlTree</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>

<div class="viewcode-block" id="Spectrum.strip"><a class="viewcode-back" href="../spec.html#spec.Spectrum.strip">[docs]</a>    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduces the size of the spectrum. Interesting if specs need to be added</span>
<span class="sd">        or stored.</span>

<span class="sd">        :param scope: accepts currently [&quot;all&quot;]</span>
<span class="sd">        :type scope: string</span>

<span class="sd">        &quot;all&quot; will remove the raw and profiled data and some internal lookup</span>
<span class="sd">        tables as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scope</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># decode, just in case ...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmzSet</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmassSet</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMzWithError</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformedPeaks</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_deconvolutedPeaks</span>  <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMassWithError</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="s">&#39;encodedData&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;encodedData&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;PY:0000000&#39;</span><span class="p">]</span> <span class="c"># this is the ID tag corresponding to &#39;encodedData&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Dont understand strip request &quot;</span><span class="p">,</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of m/z values. If the m/z values are encoded, the</span>
<span class="sd">        function :py:func:`_decode()` is used to decode the encoded data.\n</span>
<span class="sd">        The mz property can also be setted, e.g. for theoretical data.</span>
<span class="sd">        However, it is recommended to use the peaks property to set mz and</span>
<span class="sd">        intesity tuples at same time.</span>

<span class="sd">        :rtype: list</span>
<span class="sd">        :return: Returns a list of mz from the actual analysed spectrum</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decode</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span>

    <span class="nd">@mz.setter</span>
<div class="viewcode-block" id="Spectrum.mz"><a class="viewcode-back" href="../spec.html#spec.Spectrum.mz">[docs]</a>    <span class="k">def</span> <span class="nf">mz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mzList</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">mzList</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">([]),</span> <span class="s">&quot;require list of mz values ...&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">=</span> <span class="n">mzList</span>
        <span class="k">return</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of m/z values. If the m/z values are encoded, the</span>
<span class="sd">        function :py:func:`_decode()` is used to decode the encoded data.\n</span>
<span class="sd">        The mz property can also be setted, e.g. for theoretical data.</span>
<span class="sd">        However, it is recommended to use the peaks property to set mz and</span>
<span class="sd">        intesity tuples at same time.</span>

<span class="sd">        :rtype: list</span>
<span class="sd">        :return: Returns a list of mz from the actual analysed spectrum</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decode</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span>

<div class="viewcode-block" id="Spectrum.extremeValues"><a class="viewcode-back" href="../spec.html#spec.Spectrum.extremeValues">[docs]</a>    <span class="k">def</span> <span class="nf">extremeValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find extreme values, minimal and maximum mz and intensity</span>

<span class="sd">        :param key: m/z : &quot;mz&quot; or  intensity : &quot;i&quot;</span>
<span class="sd">        :type key: string</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        :return: tuple of minimal and maximum m/z or intensity</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;mz&#39;</span><span class="p">,</span><span class="s">&#39;i&#39;</span><span class="p">]:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Dont understand extreme request &quot;</span><span class="p">,</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extremeValues</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extremeValues</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;mz&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extremeValues</span><span class="p">[</span><span class="s">&#39;mz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">min</span><span class="p">([</span><span class="n">mz</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span> <span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span class="n">mz</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extremeValues</span><span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span> <span class="nb">min</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span> <span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span> <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c"># emtpy spectrum</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extremeValues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extremeValues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of the intensity values.</span>
<span class="sd">        If the intensity values are encoded, the function :py:func:`_decode()`</span>
<span class="sd">        is used to decode the encoded data.\n</span>
<span class="sd">        The i property can also be setted, e.g. for theoretical data.However, it</span>
<span class="sd">        is recommended to use the peaks property to set mz and intesity tuples</span>
<span class="sd">        at same time.</span>

<span class="sd">        :rtype: list</span>
<span class="sd">        :return: Returns a list of intensity values from the actual analysed</span>
<span class="sd">            spectrum.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decode</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

    <span class="nd">@i.setter</span>
<div class="viewcode-block" id="Spectrum.i"><a class="viewcode-back" href="../spec.html#spec.Spectrum.i">[docs]</a>    <span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">intensityList</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">intensityList</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">([]),</span> <span class="s">&quot;require list of intensity values ...&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="n">intensityList</span>
        <span class="k">return</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of peaks of the spectrum as tuples (m/z, intensity).</span>

<span class="sd">        :rtype: list of tuples</span>
<span class="sd">        :return: Returns list of tuples (m/z, intensity)</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(spectra.mzMl.gz, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     for mz, i in spectrum.peaks:</span>
<span class="sd">        ...         print(mz, i)</span>

<span class="sd">        .. note::</span>

<span class="sd">           The peaks property can also be setted, e.g. for theoretical data.</span>
<span class="sd">           It requires a list of mz/intensity tuples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;reprofiled&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroid_peaks</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">and</span> <span class="s">&#39;encodedData&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mz</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of peaks of the chromatogram as tuples (time, intensity).</span>

<span class="sd">        :rtype: list of tuples</span>
<span class="sd">        :return: Returns list of tuples (time, intensity)</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(spectra.mzMl.gz, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     for time, i in spectrum.profile:</span>
<span class="sd">        ...         print(time, i)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;reprofiled&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroid_peaks</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">and</span> <span class="s">&#39;encodedData&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mz</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span>


    <span class="nd">@peaks.setter</span>
<div class="viewcode-block" id="Spectrum.peaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.peaks">[docs]</a>    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mz_i_tuple_list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">mz_i_tuple_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">([]),</span> <span class="s">&quot;require list of tuples (mz,intensity) ...&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mz_i_tuple_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">mz_i_tuple_list</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="n">mz_i_tuple_list</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroidedPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the centroided version of a profile spectrum. Performs a Gauss</span>
<span class="sd">        fit to determine centroided mz and intensities, if the spectrum is in</span>
<span class="sd">        measured profile mode.</span>
<span class="sd">        Returns a list of tuples of fitted m/z-intesity values. If the spectrum</span>
<span class="sd">        peaks are already centroided, these peaks are returned.</span>

<span class="sd">        :rtype: list of tuples</span>
<span class="sd">        :return: Returns list of tuples (m/z, intensity)</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(spectra.mzMl.gz, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     for mz, i in spectrum.centroidedPeaks:</span>
<span class="sd">        ...         print(mz, i)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;reprofiled&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroid_peaks</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#or self._reprofiledPeaks != None:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroid_peaks</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaks</span>

    <span class="nd">@centroidedPeaks.setter</span>
<div class="viewcode-block" id="Spectrum.centroidedPeaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.centroidedPeaks">[docs]</a>    <span class="k">def</span> <span class="nf">centroidedPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mz_i_tuple_list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">mz_i_tuple_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">([]),</span> <span class="s">&quot;require list of tuples (mz,intensity) ...&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">=</span> <span class="n">mz_i_tuple_list</span>
        <span class="k">return</span>
</div>
    <span class="k">def</span> <span class="nf">_centroid_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a Gauss fit to centroid the peaks for the property</span>
<span class="sd">        :py:attr:`centroidedPeaks`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">isProfile</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">&#39;profile&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                    <span class="n">isProfile</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isProfile</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s">&#39;reprofiled&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">intensity_array</span> <span class="o">=</span> <span class="p">[</span> <span class="n">i</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reprofiledPeaks</span> <span class="p">]</span>
                <span class="n">mz_array</span> <span class="o">=</span> <span class="p">[</span> <span class="n">mz</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reprofiledPeaks</span> <span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;reprofiled&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intensity_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span>
                <span class="n">mz_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mz</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intensity_array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">intensity_array</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">intensity_array</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># local maximum ...</span>
                    <span class="c">#if 827 &lt;= mz_array[pos] &lt;= 828:</span>
                    <span class="c">#    print(&quot;::&quot;,i,&quot;@&quot;,mz_array[pos])</span>
                    <span class="c">#    print(&quot;Found maximum&quot;,i,&quot;@&quot;,mz_array[pos],intensity_array[pos-1] ,&#39;&lt;&#39; ,i ,&quot;&gt; &quot;,intensity_array[pos+1] )</span>
                    <span class="n">x1</span>  <span class="o">=</span> <span class="n">mz_array</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1</span>  <span class="o">=</span> <span class="n">intensity_array</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">x2</span>  <span class="o">=</span> <span class="n">mz_array</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                    <span class="n">y2</span>  <span class="o">=</span> <span class="n">intensity_array</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                    <span class="n">x3</span>  <span class="o">=</span> <span class="n">mz_array</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y3</span>  <span class="o">=</span> <span class="n">intensity_array</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    
                    <span class="k">if</span> <span class="n">x2</span><span class="o">-</span><span class="n">x1</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">x3</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span> <span class="o">&lt;</span> <span class="n">x3</span><span class="o">-</span><span class="n">x2</span><span class="p">:</span>
                        <span class="c"># no gauss fit if distance between mz values is too large</span>
                        <span class="k">continue</span>
                    <span class="c">#print(x1,y1,x2,y2,x3,y3)</span>
                    <span class="k">if</span> <span class="n">y3</span> <span class="o">==</span> <span class="n">y1</span><span class="p">:</span>
                        <span class="c"># i.e. a reprofiledSpec</span>
                        <span class="n">x1</span>  <span class="o">=</span> <span class="n">mz_array</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
                        <span class="n">y1</span>  <span class="o">=</span> <span class="n">intensity_array</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
                        <span class="n">x3</span>  <span class="o">=</span> <span class="n">mz_array</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span>
                        <span class="n">y3</span>  <span class="o">=</span> <span class="n">intensity_array</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">doubleLog</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y2</span><span class="o">/</span><span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y3</span><span class="o">/</span><span class="n">y1</span><span class="p">)</span>
                        <span class="n">mue</span> <span class="o">=</span> <span class="p">(</span><span class="n">doubleLog</span><span class="o">*</span><span class="p">(</span> <span class="n">x1</span><span class="o">*</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x3</span><span class="o">*</span><span class="n">x3</span> <span class="p">)</span> <span class="o">-</span> <span class="n">x1</span><span class="o">*</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">*</span><span class="n">x2</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">doubleLog</span><span class="o">*</span><span class="p">(</span><span class="n">x3</span><span class="o">-</span><span class="n">x1</span><span class="p">))</span>
                        <span class="n">cSquarred</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x2</span><span class="o">*</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="o">*</span><span class="n">x1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x2</span><span class="o">*</span><span class="n">mue</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x1</span><span class="o">*</span><span class="n">mue</span> <span class="p">)</span><span class="o">/</span> <span class="p">(</span> <span class="mi">2</span><span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y1</span><span class="o">/</span><span class="n">y2</span> <span class="p">))</span>
                        <span class="n">A</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">mue</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">mue</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="n">cSquarred</span><span class="p">)</span> <span class="p">)</span>
                        
                        <span class="c">#if A &gt; 1e20:</span>
                            <span class="c">#print(mue, A, doubleLog, cSquarred)</span>
                            <span class="c">#print(x1, &quot;\t&quot;, y1)</span>
                            <span class="c">#print(x2, &quot;\t&quot;, y2)</span>
                            <span class="c">#print(x3, &quot;\t&quot;, y3)</span>
                            <span class="c">#print()</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mue</span><span class="p">,</span><span class="n">A</span><span class="p">))</span>
            <span class="c">#for mue, A in tmp:</span>
                <span class="c">#print(mue, &quot;\t&quot;, A)</span>
            <span class="k">return</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Spectrum.xmlTree"><a class="viewcode-back" href="../spec.html#spec.Spectrum.xmlTree">[docs]</a>    <span class="k">def</span> <span class="nf">xmlTree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        xmlTree property returns an iterator over the original</span>
<span class="sd">        xmlTree structure the spectrum was initilized with.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; for element in spectrum.xmlTree:</span>
<span class="sd">        ...   print( element, element.tag, element.items() )</span>

<span class="sd">        please refer to the xml documentation of Python and cElementTree</span>
<span class="sd">        for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmlTree</span><span class="o">.</span><span class="n">getiterator</span><span class="p">()</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Spectrum.tmzSet"><a class="viewcode-back" href="../spec.html#spec.Spectrum.tmzSet">[docs]</a>    <span class="k">def</span> <span class="nf">tmzSet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a set out of transformed m/z values (including all values in the defined imprecision).</span>

<span class="sd">        :rtype: set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmzSet</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmzSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tmzSet</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span>
                                    <span class="nb">range</span><span class="p">(</span>
                                            <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mz</span> <span class="o">-</span> <span class="p">(</span><span class="n">mz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span><span class="p">)),</span>
                                            <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mz</span> <span class="o">+</span> <span class="p">(</span><span class="n">mz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmzSet</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Spectrum.tmassSet"><a class="viewcode-back" href="../spec.html#spec.Spectrum.tmassSet">[docs]</a>    <span class="k">def</span> <span class="nf">tmassSet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates a set out of transformed mass values (including all values in the defined imprecision).</span>

<span class="sd">        :rtype: set</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmassSet</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmassSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transformed_mass_with_error</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmassSet</span>
</div>
<div class="viewcode-block" id="Spectrum.deRef"><a class="viewcode-back" href="../spec.html#spec.Spectrum.deRef">[docs]</a>    <span class="k">def</span> <span class="nf">deRef</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Strip some heavy data and return deepcopy of spectrum.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(file_to_read, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spec in run:</span>
<span class="sd">        ...     tmp = spec.deRef()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Spectrum.reduce"><a class="viewcode-back" href="../spec.html#spec.Spectrum.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mzRange</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Works on peaks and reduces spectrum to a m/z range.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(file_to_read, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spec in run:</span>
<span class="sd">        ...     spec.reduce( mzRange = (100,200) )</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#NOTE Total ion current should be adjusted as well, I guess ;)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">mzRange</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(()),</span> <span class="s">&quot;require tuple of (min,max) mz range to reduce spectrum&quot;</span>
        <span class="k">if</span> <span class="n">mzRange</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">tmp_peaks</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="k">if</span> <span class="n">mzRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">mz</span> <span class="o">&lt;=</span> <span class="n">mzRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="n">scope</span> <span class="o">=</span> <span class="s">&#39;not_all&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">tmp_peaks</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Spectrum.removeNoise"><a class="viewcode-back" href="../spec.html#spec.Spectrum.removeNoise">[docs]</a>    <span class="k">def</span> <span class="nf">removeNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s">&#39;median&#39;</span><span class="p">,</span> <span class="n">noiseLevel</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to remove noise from peaks, centroided peaks and reprofiled</span>
<span class="sd">        peaks.</span>

<span class="sd">        :param mode: define mode for removing noise. Default = &quot;median&quot;</span>
<span class="sd">            (other modes: &quot;mean&quot;, &quot;mad&quot;)</span>
<span class="sd">        :type mode: string</span>
<span class="sd">        :rtype: list of tuples</span>
<span class="sd">        :return: Returns a list with tuples of m/z-intensity pairs above the</span>
<span class="sd">            noise threshold</span>

<span class="sd">        mad &lt; median &lt; mean</span>

<span class="sd">        Threshold is calculated over the mad/median/mean of all intensity values.</span>
<span class="sd">        (mad = mean absolute deviation)</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(spectra.mzML.gz, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     for mz, i in spectrum.removeNoise( mode = &#39;mean&#39;):</span>
<span class="sd">        ...         print(mz, i)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">noiseLevel</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">noiseLevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimatedNoiseLevel</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>  <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>  <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">noiseLevel</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaks</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span>  <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">noiseLevel</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Spectrum.highestPeaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.highestPeaks">[docs]</a>    <span class="k">def</span> <span class="nf">highestPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to retrieve the n-highest centroided peaks of the spectrum.</span>

<span class="sd">        :param n: Number of n-highest peaks</span>
<span class="sd">        :type n: int</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :return: list of centroided peaks (mz, intensity tuples)</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(&quot;../mzML_example_files/deconvolution.mzML.gz&quot;, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     if spectrum[&quot;ms level&quot;] == 2:</span>
<span class="sd">        ...         if spectrum[&quot;id&quot;] == 1770:</span>
<span class="sd">        ...             for mz,i in spectrum.highestPeaks(5):</span>
<span class="sd">        ...                print(mz,i)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaksSortedByI</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaksSortedByI</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidedPeaksSortedByI</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>
</div>
<div class="viewcode-block" id="Spectrum.estimatedNoiseLevel"><a class="viewcode-back" href="../spec.html#spec.Spectrum.estimatedNoiseLevel">[docs]</a>    <span class="k">def</span> <span class="nf">estimatedNoiseLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s">&#39;median&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates noise threshold for function :py:func:`removeNoise`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="s">&#39;noiseLevelEstimate&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="s">&#39;noiseLevelEstimate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;noiseLevelEstimate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;median&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;noiseLevelEstimate&#39;</span><span class="p">][</span><span class="s">&#39;median&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_median</span><span class="p">([</span> <span class="n">i</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;mad&#39;</span><span class="p">:</span>
                <span class="n">median</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimatedNoiseLevel</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s">&#39;median&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;noiseLevelEstimate&#39;</span><span class="p">][</span><span class="s">&#39;mad&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_median</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">median</span><span class="p">)</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;mean&#39;</span><span class="p">:</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">))</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;noiseLevelEstimate&#39;</span><span class="p">][</span><span class="s">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;noiseLevelEstimate&#39;</span><span class="p">][</span><span class="s">&#39;variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">i</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;dont understand noise level estimation method call&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;noiseLevelEstimate&#39;</span><span class="p">][</span><span class="n">mode</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">_median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">median</span> <span class="o">=</span>   <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="p">)))]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="p">)))]</span> <span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">median</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">median</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Spectrum.reprofiledPeaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.reprofiledPeaks">[docs]</a>    <span class="k">def</span> <span class="nf">reprofiledPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the reprofiled version of a centroided spectrum.</span>

<span class="sd">        :rtype: list of reprofiled mz,i tuples</span>
<span class="sd">        :return: Reprofiled peaks as tuple list</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(spectra.mzMl.gz, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     for mz, i in spectrum.reprofiledPeaks:</span>
<span class="sd">        ...         print(mz, i)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#NOTE self._reprofiledPeaks is a defaultdict(int) with k:mz, v:i</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mz</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reprofile_Peaks</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reprofiledPeaks</span> <span class="o">=</span> <span class="n">ddict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reprofiledPeaks</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
</div>
    <span class="k">def</span> <span class="nf">_reprofile_Peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs reprofiling for property :py:func:`reprofiledPeaks`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">ddict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mz</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">:</span>
            <span class="c"># Let&#39;s say the measured precision is 1 sigma of the signal width, i.e. 68.4%</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">mz</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="n">s</span>
            <span class="n">floor</span>  <span class="o">=</span> <span class="n">mz</span> <span class="o">-</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">s</span>   <span class="c"># Gauss curve +- 3 sigma</span>
            <span class="n">ceil</span> <span class="o">=</span> <span class="n">mz</span> <span class="o">+</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">s</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">floor</span><span class="o">*</span><span class="n">ip</span><span class="p">))</span> <span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ceil</span><span class="o">*</span><span class="n">ip</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">_</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">((</span><span class="n">mz</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">mz</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>  <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">tmp</span><span class="p">[</span> <span class="n">a</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">y</span>
                    <span class="c">#print(&quot;a&quot;, a)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;reprofiled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">tmp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">measuredPrecision</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the measured and internal precision</span>

<span class="sd">        :param value: measured precision (e.g. 5e-6)</span>
<span class="sd">        :type value: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measuredPrecision</span>

    <span class="nd">@measuredPrecision.setter</span>
<div class="viewcode-block" id="Spectrum.measuredPrecision"><a class="viewcode-back" href="../spec.html#spec.Spectrum.measuredPrecision">[docs]</a>    <span class="k">def</span> <span class="nf">measuredPrecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_measuredPrecision</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mf">50000.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)))</span>
        <span class="k">return</span>
</div>
    <span class="k">def</span> <span class="nf">_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idTag</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">idTag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">idTag</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">oldValue</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idTag</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">idTag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">oldValue</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">idTag</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idTag</span><span class="p">]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_decode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decodes the base 64 encoded and packed strings from the data.</span>

<span class="sd">        :rtype: tuple</span>
<span class="sd">        :return: Returns the unpacked data as a tuple. Returns an empty list if</span>
<span class="sd">            there is no raw data or raises an exception if data could not be</span>
<span class="sd">            decoded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;encodedData&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">compressionStated</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">n_BinaryArrayOrder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n_BinaryArrayOrder</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">compressionStated</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c">#</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_BinaryArrayOrder</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_BinaryArrayOrder</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">compressionStated</span><span class="p">:</span>
                    <span class="n">arrayType</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="n">encodingType</span>  <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">][</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">][</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">arrayType</span><span class="p">,</span> <span class="n">encodingType</span>  <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">][</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])]</span>
                    <span class="n">compression</span> <span class="o">=</span> <span class="s">&#39;no&#39;</span>

                <span class="k">if</span> <span class="n">encodingType</span> <span class="o">==</span> <span class="s">&#39;32-bit float&#39;</span><span class="p">:</span>
                    <span class="n">floattype</span> <span class="o">=</span> <span class="s">&#39;f&#39;</span>
                <span class="k">elif</span> <span class="n">encodingType</span> <span class="o">==</span> <span class="s">&#39;64-bit float&#39;</span><span class="p">:</span>
                    <span class="n">floattype</span> <span class="o">=</span> <span class="s">&#39;d&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">floattype</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;New data encoding detected, please adjust parser&quot;</span><span class="p">,</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

                <span class="n">unpackedData</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;encodedData&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;encodedData&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;encodedData&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">decodedData</span>  <span class="o">=</span> <span class="n">b64dec</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;encodedData&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;utf-8&quot;</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">compression</span> <span class="o">==</span> <span class="s">&#39;zlib&#39;</span><span class="p">:</span>
                        <span class="n">decodedData</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">decodedData</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">compression</span> <span class="o">==</span> <span class="s">&#39;no&#39;</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;New data compression ({0}) detected, please adjust parser&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compression</span><span class="p">),</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                        <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;{endian}{arraylength}{floattype}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">endian</span> <span class="o">=</span> <span class="s">&quot;&lt;&quot;</span> <span class="p">,</span> <span class="n">arraylength</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;defaultArrayLength&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">floattype</span> <span class="o">=</span> <span class="n">floattype</span> <span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">unpackedData</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span> <span class="n">fmt</span> <span class="p">,</span> <span class="n">decodedData</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span> <span class="c"># NOTE raises struct.error, but cannot be checked for here</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t extract data {0} fmt: {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arrayType</span><span class="p">,</span> <span class="n">fmt</span><span class="p">),</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                        <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;encodedData&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">pos</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)]),</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                        <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">arrayType</span> <span class="o">==</span> <span class="s">&#39;mz&#39;</span> <span class="ow">or</span> <span class="n">arrayType</span> <span class="o">==</span> <span class="s">&#39;time&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mz</span> <span class="o">=</span> <span class="n">unpackedData</span>
                <span class="k">elif</span> <span class="n">arrayType</span> <span class="o">==</span> <span class="s">&#39;i&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="n">unpackedData</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Arraytype {0} not supported ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arrayType</span><span class="p">),</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                    <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="Spectrum.hasPeak"><a class="viewcode-back" href="../spec.html#spec.Spectrum.hasPeak">[docs]</a>    <span class="k">def</span> <span class="nf">hasPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mz2find</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a Spectrum has a certain peak.</span>
<span class="sd">        Needs a certain mz value as input and returns a list of peaks if a peak</span>
<span class="sd">        is found in the spectrum, otherwise ``[]`` is returned.</span>
<span class="sd">        Every peak is a tuple of m/z and intensity.</span>

<span class="sd">        :param mz2find: mz value which should be found</span>
<span class="sd">        :type mz2find: float</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :return: m/z and intensity as tuple in list</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml, get_example_file</span>
<span class="sd">        &gt;&gt;&gt; example_file = get_example_file.open_example(&#39;deconvolution.mzML.gz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(example_file, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     if spectrum[&quot;ms level&quot;] == 2:</span>
<span class="sd">        ...             peak_to_find = spectrum.hasPeak(1016.5404)</span>
<span class="sd">        ...             print(peak_to_find)</span>
<span class="sd">        [(1016.5404, 19141.735187697403)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformMZ</span><span class="p">(</span><span class="n">mz2find</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_mz_with_error</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

        <span class="c"># NOTE this can return a result if a peak is found within 20.08 ppm (for a 20 ppm spectrum) ...</span>
</div>
<div class="viewcode-block" id="Spectrum.hasDeconvolutedPeak"><a class="viewcode-back" href="../spec.html#spec.Spectrum.hasDeconvolutedPeak">[docs]</a>    <span class="k">def</span> <span class="nf">hasDeconvolutedPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass2find</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a deconvoluted spectrum contains a certain peak.</span>
<span class="sd">        Needs a mass value as input and returns a list of peaks if a peak</span>
<span class="sd">        is found in the spectrum. If the mass is not found ``[]`` is</span>
<span class="sd">        returned.</span>
<span class="sd">        Every peak is a tuple of m/z and intensity.</span>

<span class="sd">        :param mass2find: mass value which should be found</span>
<span class="sd">        :type mass2find: float</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :return: mass and intensity as tuple in list if mass is found,</span>
<span class="sd">            otherwise ``[]``</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml, get_example_file</span>
<span class="sd">        &gt;&gt;&gt; example_file = get_example_file.open_example(&#39;deconvolution.mzML.gz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader(example_file, MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     if spectrum[&quot;ms level&quot;] == 2:</span>
<span class="sd">        ...             peak_to_find = spectrum.hasDeconvolutedPeak(1044.5804)</span>
<span class="sd">        ...             print(peak_to_find)</span>
<span class="sd">        [(1044.5596, 3809.4356300564586)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformMZ</span><span class="p">(</span><span class="n">mass2find</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_mass_with_error</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_transformed_mz_with_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns transformed m/z value with error</span>

<span class="sd">        :rtype: dictionary</span>
<span class="sd">        :return: Transformed m/z values in dictionary {m/z_with_error :</span>
<span class="sd">            [(m/z,intensity), ...], ...}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMzWithError</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMzWithError</span> <span class="o">=</span> <span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t_mz_with_error</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mz</span> <span class="o">-</span> <span class="p">(</span><span class="n">mz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span><span class="p">)),</span>
                                             <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mz</span> <span class="o">+</span> <span class="p">(</span><span class="n">mz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMzWithError</span><span class="p">[</span><span class="n">t_mz_with_error</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mz</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMzWithError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_transformed_mass_with_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns transformed mass value with error</span>

<span class="sd">        :rtype: dictionary</span>
<span class="sd">        :return: Transformed mass values in dictionary {mass_with_error:</span>
<span class="sd">            (mass,intensity), ...}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMassWithError</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMassWithError</span> <span class="o">=</span> <span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">mass</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolutedPeaks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t_mass_with_error</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mass</span> <span class="o">-</span> <span class="p">(</span><span class="n">mass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span><span class="p">)),</span>
                                               <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mass</span> <span class="o">+</span> <span class="p">(</span><span class="n">mass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMassWithError</span><span class="p">[</span><span class="n">t_mass_with_error</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mass</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformedMassWithError</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Spectrum.transformedPeaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.transformedPeaks">[docs]</a>    <span class="k">def</span> <span class="nf">transformedPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        m/z value is multiplied by the internal precision</span>

<span class="sd">        :rtype: list of tuples</span>
<span class="sd">        :return: Returns a list of peaks (tuples of mz and intensity). Float m/z</span>
<span class="sd">            values are adjusted by the internal precision to integers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformedPeaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformedPeaks</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformMZ</span><span class="p">(</span><span class="n">mz</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformedPeaks</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Spectrum.transformed_deconvolutedPeaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.transformed_deconvolutedPeaks">[docs]</a>    <span class="k">def</span> <span class="nf">transformed_deconvolutedPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvoluted mz value is multiplied by the internal precision</span>

<span class="sd">        :rtype: list of tuples</span>
<span class="sd">        :return: Returns a list of peaks (tuples of mz and intensity). Float m/z</span>
<span class="sd">            values are adjusted by the internal precision to integers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_deconvolutedPeaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_deconvolutedPeaks</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformMZ</span><span class="p">(</span><span class="n">mass</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">mass</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolutedPeaks</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_deconvolutedPeaks</span>
</div>
    <span class="k">def</span> <span class="nf">_mz2mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the uncharged mass for a given mz value</span>

<span class="sd">        :param mz: m/z value</span>
<span class="sd">        :type mz: float</span>
<span class="sd">        :param charge: charge</span>
<span class="sd">        :type charge: int</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :return: Returns mass of a given m/z value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">mz</span> <span class="o">-</span> <span class="n">PROTON</span><span class="p">)</span> <span class="o">*</span> <span class="n">charge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group mz (or mass) values according to the given ppm value. The mean</span>
<span class="sd">        value of grouped peaks is stored. When an intensity tuple is given, the</span>
<span class="sd">        corresponding intensity are summed up and stored.</span>

<span class="sd">        :rtype: list</span>
<span class="sd">        :return: list of peaks</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mz_tuple</span><span class="p">,</span> <span class="n">intensity_tuple</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">peaks</span><span class="p">)</span>

        <span class="n">count_ungrouped</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mz_list_grouped</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># iterate over all entries for grouping</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mz_tuple</span><span class="p">):</span>
            <span class="n">target</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">mz_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mz_tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mz_tuple</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="c"># no peaks have to be grouped, just add the current peak to the result and go in with the next peak</span>
                <span class="n">mz_list_grouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">mz_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intensity_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># potential overlapping peaks are found.</span>
                <span class="c"># check wether the mz value of the j index does not overlap with the next j+1 index</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">group</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mz_tuple</span><span class="p">):</span>
                    <span class="n">target_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">mz_tuple</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">target_new</span> <span class="o">&gt;=</span> <span class="n">mz_tuple</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">group</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
                    <span class="c"># group the peaks, calculate mean</span>
                    <span class="n">mean</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mz_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mz_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">intensity_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">intensity_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">mz_list_grouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">mean</span><span class="p">,</span> <span class="n">intensity_sum</span><span class="p">]))</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># peaks are ambigious, no grouping is applied --&gt; every peak is stored</span>
                    <span class="c"># this incident is counted.</span>
                    <span class="n">count_ungrouped</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
                    <span class="c"># adding each element between i and j</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">mz_list_grouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">mz_tuple</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">intensity_tuple</span><span class="p">[</span><span class="n">k</span><span class="p">]]))</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">count_ungrouped</span><span class="p">:</span>
            <span class="c"># if ungrouped entries occured, this is reported</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;{0} elements could not be grouped due to an overlap.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count_ungrouped</span><span class="p">),</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mz_list_grouped</span>

    <span class="k">def</span> <span class="nf">_get_deisotopedMZ_for_chargeDeconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppmFactor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">minCharge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxCharge</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">maxNextPeaks</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the deisotoped m/z value as an input for the charge deconvolution</span>

<span class="sd">        :param ppmFactor: ppm factor</span>
<span class="sd">        :type ppmFactor: int</span>
<span class="sd">        :param minCharge: minimum charge considered</span>
<span class="sd">        :type minCharge: int</span>
<span class="sd">        :param maxCharge: maximum charge considered</span>
<span class="sd">        :type maxCharge: int</span>
<span class="sd">        :param maxNextPeaks: maximum length for isotope envelope</span>
<span class="sd">        :type maxNextPaks: int</span>

<span class="sd">        :rtype: list of tuples</span>
<span class="sd">        :return: Monoisotopic peak [(m/z, intensity_sum, charge, found),...]</span>

<span class="sd">        .. note::</span>

<span class="sd">           The argument *maxNextPeaks* is just to make sure that the isotope</span>
<span class="sd">           envelope doesnt get too long. This limit is not reached usually.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mz</span><span class="p">,</span> <span class="n">intensities</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">centroidedPeaks</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c">#empty spectrum</span>
            <span class="nb">exit</span><span class="p">()</span>
            <span class="n">mz</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">monoisotopicPeaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mz</span><span class="p">)</span>
        <span class="n">override</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">charge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxCharge</span><span class="p">,</span> <span class="n">minCharge</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c"># check absence of isotope envelope peaks before the current peak</span>
                <span class="c">#print(&quot;Analyzing mz, charge:&quot;, mz[i], charge)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># the current peak is the first peak, no preceding peak is available, so this is a monoisotopic candidate</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ISOTOPE_AVERAGE_DIFFERENCE</span> <span class="o">/</span> <span class="n">charge</span>
                    <span class="n">target_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ppmFactor</span><span class="p">)</span> <span class="c"># min and max should be calculated in one step (so that self.ppm() is not called twice)</span>
                    <span class="n">target_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ppmFactor</span><span class="p">)</span>
                    <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mz</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target_min</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mz</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target_max</span><span class="p">:</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="c"># Found preceeding peak, break goes to the next peak</span>
                            <span class="k">break</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="c"># if a potential preceding peak for the current peak is found, jump to the next peak</span>
                <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="sd">&#39;&#39;&#39; check presence of isotope envelope after the current peak&#39;&#39;&#39;</span>
                <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">intensity_sum</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">local_max</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">i_envelope</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxNextPeaks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">i_envelope</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mz</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ISOTOPE_AVERAGE_DIFFERENCE</span> <span class="o">*</span> <span class="n">i_envelope</span><span class="p">)</span><span class="o">/</span> <span class="n">charge</span>
                    <span class="n">target_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">target_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="ow">and</span> <span class="n">mz</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target_max</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mz</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target_min</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">intensities</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">intensities</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">local_max</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">elif</span> <span class="n">local_max</span> <span class="ow">and</span> <span class="n">intensities</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intensities</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="c"># this would be a second local max, so this is no longer considered in the isotope envelope</span>
                                <span class="k">break</span>
                            <span class="n">found</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="c">#print(mz[k])</span>
                            <span class="n">intensity_sum</span> <span class="o">+=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="c"># go to next k and reset the target</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">:</span>
                                <span class="n">target</span> <span class="o">=</span> <span class="n">mz</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">ISOTOPE_AVERAGE_DIFFERENCE</span> <span class="o">/</span> <span class="n">charge</span>
                                <span class="n">target_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">target_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">found</span> <span class="o">&lt;=</span> <span class="n">i_envelope</span><span class="p">:</span>
                        <span class="k">break</span>
                        <span class="c"># an isotope envelope is not supposed to have missing peaks</span>

                <span class="k">if</span> <span class="n">found</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">monoisotopicPeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">mz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">intensity_sum</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">found</span><span class="p">]))</span>
                    <span class="k">break</span>
                    <span class="c"># as the first peak of the isotope envelope is added here, this is a monoisotopic peak.</span>
                    <span class="c"># the charge derived from the isotope envelope is the highest charge which is possible.</span>
        <span class="k">return</span> <span class="n">monoisotopicPeaks</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Spectrum.deconvolutedPeaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.deconvolutedPeaks">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolutedPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calling :py:func:`spec.Spectrum.deconvolute_peaks` with standard</span>
<span class="sd">        parameters, which calculates uncharged masses and returns deconvoluted</span>
<span class="sd">        peaks.</span>

<span class="sd">        :rtype: list</span>
<span class="sd">        :return: list of deconvoluted peaks (mass (instead of m/z) / intensity tuples)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deconvolutedPeaks</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deconvolutedPeaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute_peaks</span><span class="p">(</span><span class="n">ppmFactor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">minCharge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxCharge</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">maxNextPeaks</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deconvolutedPeaks</span>
</div>
<div class="viewcode-block" id="Spectrum.deconvolute_peaks"><a class="viewcode-back" href="../spec.html#spec.Spectrum.deconvolute_peaks">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppmFactor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">minCharge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxCharge</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">maxNextPeaks</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculating uncharged masses and returning deconvoluted peaks.</span>

<span class="sd">        The deconvolution of spectra is done by first identifying isotope envelopes and</span>
<span class="sd">        the charge state of this envelopes. The first peak of an isotope envelope is choosen</span>
<span class="sd">        as the monoisotopic peak for which the mass is calculated from the m/z ratio.</span>
<span class="sd">        Isotope envelopes are identified by searching the centroided spectrum for peaks</span>
<span class="sd">        which show no preceding isotope peak within a specified mass accuracy. To be</span>
<span class="sd">        sure, the measured mass accuracy is multiplied by a user adjustable factor</span>
<span class="sd">        (``ppmFactor``). When the current peak meets the criteria with no preceding peaks, the</span>
<span class="sd">        following peaks are analysed. The following peaks are considered to be part of</span>
<span class="sd">        the isotope envelope, as long as they fit within the measured precision and</span>
<span class="sd">        only one local maximum is present. The second local maximum is not considered</span>
<span class="sd">        as the starting point of a new isotope envelope as one cannot be sure were this</span>
<span class="sd">        isotope envelope starts. However, the last peak before the second local maximum</span>
<span class="sd">        is considered to be part of the isotope envelope from the first local maximum,</span>
<span class="sd">        as the intensity of this peak shouldn&#39;t have a big influence on the whole</span>
<span class="sd">        isotope envelope intensity.</span>
<span class="sd">        The charge range for detecting isotope envelopes can be specified (``minCharge``,</span>
<span class="sd">        ``maxCharge``). An isotope envelope always gets the highest possible charge.</span>
<span class="sd">        With the charge the mass can be calculated from the m/z value of the first peak</span>
<span class="sd">        of the isotope envelope. The intensity of the deconvoluted peak results from</span>
<span class="sd">        the sum of all isotope envelope peaks.</span>
<span class="sd">        In a last step, deconvoluted peaks are grouped together within the measured</span>
<span class="sd">        precision. This is necessary because isotope envelopes from the same fragment</span>
<span class="sd">        but with different charge states can leed to slightly different deconvoluted</span>
<span class="sd">        peaks.</span>

<span class="sd">        :param ppmFactor: ppm factor (imprecision factor)</span>
<span class="sd">        :type ppmFactor: int</span>
<span class="sd">        :param minCharge: minimum charge considered</span>
<span class="sd">        :type minCharge: int</span>
<span class="sd">        :param maxCharge: maximum charge considered</span>
<span class="sd">        :type maxCharge: int</span>
<span class="sd">        :param maxNextPeaks: maximum length for isotope envelope</span>
<span class="sd">        :type maxNextPaks: int</span>

<span class="sd">        :rtype: tuple (mass, intensity)</span>
<span class="sd">        :return: Deconvoluted peaks, mass (instead of m/z) and intensity are</span>
<span class="sd">            returned</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span> <span class="o">&gt;</span> <span class="mf">50e-6</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;{0} ppm is too high for deconvolution. Please make sure to use spectra with &lt; 50 ppm.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">),</span> <span class="nb">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># calculate monoisotopic m/z and charge</span>
        <span class="n">interestingPeaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_deisotopedMZ_for_chargeDeconvolution</span><span class="p">(</span><span class="n">ppmFactor</span><span class="p">,</span> <span class="n">minCharge</span><span class="p">,</span> <span class="n">maxCharge</span><span class="p">,</span> <span class="n">maxNextPeaks</span><span class="p">)</span>

        <span class="c"># charge deconvolution</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">intensity</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">interestingPeaks</span><span class="p">:</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz2mass</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">mass</span><span class="p">,</span> <span class="n">intensity</span><span class="p">]))</span>

        <span class="c"># sort the result corresponding to the mass (due to the mz to mass conversion, the values are no longer sorted)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c"># check on empty result list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># no peaks could be identified for charge deconvolution.</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c"># group peaks</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">ppm2abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">ppmValue</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the value plus (or minus, dependent on direction) the</span>
<span class="sd">        imprecession for this value.</span>

<span class="sd">        :param value: m/z value</span>
<span class="sd">        :type value: float</span>
<span class="sd">        :param ppmvalue: ppm value</span>
<span class="sd">        :type ppmvalue: int</span>
<span class="sd">        :param direction: plus or minus the considered m/z value. The argument</span>
<span class="sd">            *direction* should be 1 or -1</span>
<span class="sd">        :type direction: int</span>
<span class="sd">        :param factor: multiplication factor for the imprecision.The argument</span>
<span class="sd">            *factor* should be bigger than 0.</span>
<span class="sd">        :type factor: int</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :return: imprecision for a given value</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="p">(</span><span class="n">ppmValue</span> <span class="o">*</span> <span class="n">factor</span><span class="p">))</span> <span class="o">*</span> <span class="n">direction</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Spectrum.hasOverlappingPeak"><a class="viewcode-back" href="../spec.html#spec.Spectrum.hasOverlappingPeak">[docs]</a>    <span class="k">def</span> <span class="nf">hasOverlappingPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a spetrum has more than one peak for a given m/z value and within the measured precision</span>

<span class="sd">        :param mz: m/z value which should be checked</span>
<span class="sd">        :type mz: float</span>
<span class="sd">        :return: Returns ``True`` if a nearby peak is detected, otherwise ``False``</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">minus_or_plus</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">,</span> <span class="n">minus_or_plus</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasPeak</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm2abs</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">temp</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="Spectrum.similarityTo"><a class="viewcode-back" href="../spec.html#spec.Spectrum.similarityTo">[docs]</a>    <span class="k">def</span> <span class="nf">similarityTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">spec2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares two spectra and returns cosine</span>

<span class="sd">        :param spec2: another pymzml spectrum that is compated to the current spectrum.</span>
<span class="sd">        :type spec2: pymzml.spec.Spectrum</span>
<span class="sd">        :return: value between 0 and 1, i.e. the cosine between the two spectra.</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        .. note::</span>
<span class="sd">            Spectra data is transformed into an n-dimensional vector,</span>
<span class="sd">            whereas mz values are binned in bins of 10 m/z and the intensities are added up.</span>
<span class="sd">            Then the cosine is calculated between those two vectors.</span>
<span class="sd">            The more similar the specs are, the closer the value is to 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec2</span><span class="p">,</span><span class="n">Spectrum</span><span class="p">)</span> <span class="p">,</span> <span class="s">&quot;Spectrum2 is not a pymzML spectrum&quot;</span>

        <span class="n">vector1</span> <span class="o">=</span> <span class="n">ddict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">vector2</span> <span class="o">=</span> <span class="n">ddict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">mzs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">:</span>
            <span class="n">vector1</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">i</span>
            <span class="n">mzs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spec2</span><span class="o">.</span><span class="n">peaks</span><span class="p">:</span>
            <span class="n">vector2</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">i</span>
            <span class="n">mzs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_v1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_v2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">mz</span> <span class="ow">in</span> <span class="n">mzs</span><span class="p">:</span>
            <span class="n">int1</span> <span class="o">=</span> <span class="n">vector1</span><span class="p">[</span><span class="n">mz</span><span class="p">]</span>
            <span class="n">int2</span> <span class="o">=</span> <span class="n">vector2</span><span class="p">[</span><span class="n">mz</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">+=</span> <span class="n">int1</span><span class="o">*</span><span class="n">int2</span>
            <span class="n">n_v1</span> <span class="o">+=</span> <span class="n">int1</span><span class="o">*</span><span class="n">int1</span>
            <span class="n">n_v2</span> <span class="o">+=</span> <span class="n">int2</span><span class="o">*</span><span class="n">int2</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cosine</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_v1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_v2</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">cosine</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">cosine</span>

</div>
    <span class="k">def</span> <span class="nf">transformMZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pymzml uses an internal precision to different tasks. This precision depends on the</span>
<span class="sd">        measured prescision and is calculated when :py:func:`spec.Spectrum.measuredPrecision` is invoked.</span>
<span class="sd">        transformMZ can be used to transform mz values into the internal standard.</span>

<span class="sd">        :param value: mz value</span>
<span class="sd">        :type value: float</span>
<span class="sd">        :return: transformed value</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        this value can be used to probe internal dictionaries, lists or sets, e.g. spectrum.tmzSet.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import pymzml</span>
<span class="sd">        &gt;&gt;&gt; mzValues_to_test = set()</span>
<span class="sd">        &gt;&gt;&gt; run = pymzml.run.Reader( &quot;test.mzML.gz&quot; , MS1_Precision = 5e-6, MSn_Precision = 20e-6)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; for spectrum in run:</span>
<span class="sd">        ...     if spectrum[&quot;ms level&quot;] == 2:</span>
<span class="sd">        ...             peak_to_find = spectrum.hasDeconvolutedPeak(1044.5804)</span>
<span class="sd">        ...             print(peak_to_find)</span>
<span class="sd">        [(1044.5596, 3809.4356300564586)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalPrecision</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">initFromTreeObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">treeObject</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        treeObject.get(&#39;nativeID&#39;)</span>
<span class="sd">        print(treeObject)</span>
<span class="sd">        print(treeObject.items())</span>
<span class="sd">        for _ in treeObject.getiterator():</span>
<span class="sd">            print(_.tag,_.items())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xmlTree</span> <span class="o">=</span> <span class="n">treeObject</span>
        <span class="c">#</span>
        <span class="k">if</span> <span class="n">treeObject</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;}chromatogram&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">treeObject</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s">&#39;ms level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                1.1.0  &gt;&gt; &lt;spectrum id=&quot;spectrum=1019&quot; index=&quot;8&quot; defaultArrayLength=&quot;431&quot;&gt;</span>
<span class="sd">                1.1.0  &gt;&gt; &lt;spectrum id=&quot;scan=3&quot; index=&quot;0&quot; sourceFileRef=&quot;SF1&quot; defaultArrayLength=&quot;92&quot;&gt;</span>
<span class="sd">                1.0.0  &gt;&gt; &lt;spectrum index=&quot;317&quot; id=&quot;S318&quot; nativeID=&quot;318&quot; defaultArrayLength=&quot;34&quot;&gt;</span>
<span class="sd">                0.99.1 &gt;&gt; &lt;spectrum id=&quot;S20&quot; scanNumber=&quot;20&quot; msLevel=&quot;2&quot;&gt;</span>
<span class="sd">                so far regex hold for this ...</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="s">r&#39;[0-9]*$&#39;</span><span class="p">,</span>   <span class="n">treeObject</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>  <span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;defaultArrayLength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">treeObject</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;defaultArrayLength&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">treeObject</span><span class="o">.</span><span class="n">getiterator</span><span class="p">():</span>
            <span class="n">accession</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;accession&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">[</span><span class="n">accession</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;cvParam&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">accession</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">mzmlTag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;valuesToExtract&#39;</span><span class="p">]:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="p">(</span><span class="n">idTag</span> <span class="o">=</span> <span class="n">accession</span><span class="p">,</span>
                                       <span class="n">value</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mzmlTag</span><span class="p">),</span>
                                       <span class="n">name</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">mzmlTag</span> <span class="o">==</span> <span class="s">&#39;unitName&#39;</span><span class="p">:</span>
                                <span class="k">continue</span>
                                <span class="c"># this allows parsing of mzML files generated with ProteomeDiscoverer</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">print</span><span class="p">(</span><span class="s">&quot;kind of &#39;unitName&#39; issue again ... with {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mzmlTag</span><span class="p">))</span>
                                <span class="nb">exit</span><span class="p">()</span>

                    <span class="k">if</span>  <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;intensity array&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;arrayType&#39;</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;m/z array&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;arrayType&#39;</span><span class="p">,</span> <span class="s">&#39;mz&#39;</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;time array&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;arrayType&#39;</span><span class="p">,</span> <span class="s">&#39;time&#39;</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;32-bit float&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;encoding&#39;</span><span class="p">,</span> <span class="s">&#39;32-bit float&#39;</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;64-bit float&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;encoding&#39;</span><span class="p">,</span> <span class="s">&#39;64-bit float&#39;</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;zlib compression&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;compression&#39;</span><span class="p">,</span> <span class="s">&#39;zlib&#39;</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;accessions&#39;</span><span class="p">][</span><span class="n">accession</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;no compression&#39;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;BinaryArrayOrder&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;compression&#39;</span><span class="p">,</span> <span class="s">&#39;no&#39;</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;precursorList&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;selectedIon&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;mz&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;charge&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">subElement</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">getiterator</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">subElement</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;cvParam&#39;</span><span class="p">):</span>
                        <span class="n">accession</span> <span class="o">=</span> <span class="n">subElement</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;accession&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">accession</span> <span class="o">==</span> <span class="s">&#39;MS:1000040&#39;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;mz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subElement</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">accession</span> <span class="o">==</span> <span class="s">&#39;MS:1000041&#39;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;charge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subElement</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">accession</span> <span class="o">==</span> <span class="s">&#39;MS:1000744&#39;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;mz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subElement</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">pass</span>

            <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;binary&#39;</span><span class="p">):</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="p">(</span>    <span class="n">idTag</span> <span class="o">=</span> <span class="s">&#39;PY:0000000&#39;</span><span class="p">,</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
                                <span class="n">name</span>  <span class="o">=</span> <span class="s">&#39;encodedData&#39;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;selectedIon&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="s">&#39;MS:1000040&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;mz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;MS:1000040&#39;</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">if</span> <span class="s">&#39;MS:1000744&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;mz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;MS:1000744&#39;</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="s">&#39;precursors&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;charge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&#39;MS:1000041&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;ms level&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;MS1_Precision&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measuredPrecision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s">&#39;MSn_Precision&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">__doc__</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">pymzML 0.7.4 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Till Bald, Johannes Barth, Anna Niehues, Michael Specht, Michael Hippler, Christian Fufezan.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>